<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BarberConnect - Cliente</title>
    <link rel="manifest" href="manifest-cliente.json">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
<style>
    /* --- INICIO: NUEVOS ESTILOS DARK MODE --- */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
        font-family: system-ui, -apple-system, sans-serif; 
        background: #000; 
        height: 100vh; 
        display: flex; 
        justify-content: center; 
        align-items: center; 
    }
    .chat-container { 
        width: 100%; 
        max-width: 400px; 
        height: 100vh; 
        background: #121212; 
        color: #E0E0E0;
        display: flex; 
        flex-direction: column; 
        box-shadow: 0 0 15px rgba(255,179,0,0.1); 
    }
    .chat-header {
        background: #1E1E1E;
        color: white;
        padding: 10px 15px;
        text-align: left;
        position: relative;
        display: flex;
        justify-content: flex-start;
        align-items: center;
        gap: 15px;
        border-bottom: 1px solid #2C2C2C;
    }
    .chat-header h1 { margin: 0; font-size: 1.5em; }
    .chat-header p { margin: 5px 0 0 0; opacity: 0.7; font-size: 0.9em; color: #A0A0A0; }

    .messages-container { 
        flex: 1; 
        padding: 15px; 
        overflow-y: auto; 
        background: #121212; 
        min-height: 0; 
    }
    .message { margin-bottom: 12px; display: flex; flex-direction: column; animation: fadeIn 0.3s ease-in; }
    .message.user { align-items: flex-end; }
    .message.bot { align-items: flex-start; }
    .message-content { padding: 10px 14px; border-radius: 18px; max-width: 85%; word-wrap: break-word; line-height: 1.4; }
    .message.user .message-content { 
        background: #FFB300; 
        color: #121212; 
        font-weight: 500;
        border-bottom-right-radius: 4px; 
    }
    .message.bot .message-content { 
        background: #1E1E1E; 
        color: #E0E0E0; 
        border-bottom-left-radius: 4px; 
    }
    .message-time { font-size: 0.7em; color: #A0A0A0; margin-top: 4px; padding: 0 8px; }

    /* --- ESTILOS PARA INDICADOR DE ESCRITURA --- */
    .typing { display: flex; padding: 10px 14px; background: #1E1E1E; border-radius: 18px; border-bottom-left-radius: 4px; }
    .typing span { height: 6px; width: 6px; background: #A0A0A0; border-radius: 50%; display: block; margin: 0 2px; animation: typing 1s infinite ease-in-out; }
    .typing span:nth-child(1) { animation-delay: 0.2s; }
    .typing span:nth-child(2) { animation-delay: 0.4s; }
    .typing span:nth-child(3) { animation-delay: 0.6s; }
    @keyframes typing { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
    /* --- FIN ESTILOS INDICADOR --- */


    .input-container { 
        display: flex; 
        padding: 12px; 
        background: #1E1E1E; 
        border-top: 1px solid #2C2C2C; 
        gap: 8px; 
        align-items: center; /* Alinear verticalmente */
    }
    .message-input { 
        flex: 1; 
        padding: 10px 14px; 
        border: 1px solid #2C2C2C; 
        background-color: #121212;
        color: #E0E0E0;
        border-radius: 20px; 
        outline: none; 
        font-size: 14px; 
    }
    .message-input:focus {
        border-color: #FFB300;
    }
    .send-button { 
        padding: 10px 16px; 
        background: #FFB300; 
        color: #121212; 
        font-weight: bold;
        border: none; 
        border-radius: 20px; 
        cursor: pointer; 
    }
    .send-button:disabled { background: #555; color: #888; cursor: not-allowed; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
    

    .bot-card { 
        background-color: #1E1E1E; 
        border: 1px solid #2C2C2C; 
        border-radius: 12px; 
        padding: 16px; 
        width: 100%; 
        box-shadow: 0 2px 4px rgba(0,0,0,0.2); 
    }
    .bot-card h3 { margin: 0 0 12px 0; color: #FFFFFF; border-bottom: 1px solid #2C2C2C; padding-bottom: 8px; font-size: 1.1em; }
    .bot-card p { margin: 0 0 8px 0; line-height: 1.5; color: #A0A0A0; }
    .bot-card ul { list-style: none; padding: 0; margin: 0 0 10px 0; }
    .bot-card li { padding: 8px 0; border-bottom: 1px solid #2C2C2C; display: flex; justify-content: space-between; align-items: center; }
    .bot-card li:last-child { border-bottom: none; }
    .bot-card .helper-text { font-size: 0.8em; color: #888; margin-top: 5px; }

    .command-buttons-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; margin-top: 10px; }
    .command-button { 
        background-color: #2C2C2C; 
        border: 1px solid #444; 
        border-radius: 8px; 
        padding: 12px 8px; 
        font-size: 0.9em; 
        font-weight: 500; 
        color: #E0E0E0; 
        cursor: pointer; 
        text-align: center; 
        transition: background-color 0.2s, box-shadow 0.2s; 
        width: 100%; 
    }
    .command-button:hover { background-color: #444; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
    .command-button.full-width { grid-column: 1 / -1; }
    .command-button.confirm { background-color: #4CAF50; color: white; }
    .command-button.cancel { background-color: #F44336; color: white; }

    .header-icons { position: absolute; right: 15px; top: 50%; transform: translateY(-50%); }
    .icon-wrapper { position: relative; cursor: pointer; }
    .icon-wrapper svg { width: 26px; height: 26px; fill: white; }
    .notification-badge {
        position: absolute; top: -5px; right: -8px; background-color: #F44336; color: white;
        border-radius: 50%; width: 20px; height: 20px; font-size: 11px; display: none;
        justify-content: center; align-items: center; font-weight: bold; border: 2px solid #1E1E1E;
    }
    .notification-badge.visible { display: flex; animation: pulse-badge 2s infinite; }
    @keyframes pulse-badge { 0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7); } 70% { transform: scale(1); box-shadow: 0 0 0 8px rgba(244, 67, 54, 0); } 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); } }

    #qr-reader {
        width: 100%;
        border: 2px solid #2C2C2C;
        border-radius: 8px;
        overflow: hidden;
        margin-top: 10px;
    }
    .profile-picture-container {
        width: 50px; height: 50px; border-radius: 50%; overflow: hidden; flex-shrink: 0;
        border: 2px solid rgba(255, 255, 255, 0.5); box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .barber-profile-pic { width: 100%; height: 100%; object-fit: cover; }
    
    .menu-button {
        display: none; /* Oculto por defecto */
        flex-shrink: 0;
        padding: 8px;
        background: #2C2C2C;
        border: 1px solid #444;
        border-radius: 50%; /* Redondo */
        cursor: pointer;
        width: 38px; /* Tamaño consistente */
        height: 38px;
        transition: background-color 0.2s;
    }
    .menu-button.visible {
        display: block; /* Mostrarlo en modo chat */
    }
    .menu-button:hover {
        background-color: #444;
    }
    .menu-button svg {
        width: 100%;
        height: 100%;
        fill: #E0E0E0;
    }

    .profile-avatar-wrapper { display: flex; justify-content: center; margin-bottom: 16px; }
    .profile-avatar {
        width: 100px; height: 100px; border-radius: 50%; background-color: #FFB300; color: #121212;
        display: flex; justify-content: center; align-items: center; font-size: 2.5em; font-weight: bold;
        border: 3px solid #1E1E1E; box-shadow: 0 4px 8px rgba(0,0,0,0.3); overflow: hidden;
    }
    .profile-avatar img { width: 100%; height: 100%; object-fit: cover; }
    
    .edit-icon-button {
        background-color: #2C2C2C;
        border: 1px solid #444;
        border-radius: 6px; /* Bordes suaves */
        width: 32px;
        height: 32px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.2s;
        flex-shrink: 0; /* Evita que el botón se encoja */
    }
    .edit-icon-button:hover {
        background-color: #444;
    }
    .edit-icon-button svg {
        width: 16px;
        height: 16px;
        fill: #E0E0E0; /* Color del ícono */
    }
    .bot-card li { 
        padding: 8px 0; border-bottom: 1px solid #2C2C2C; 
        display: flex; justify-content: space-between; align-items: center; 
    }
    .bot-card .item-name { font-weight: 500; color: #E0E0E0; }
    .bot-card .item-detail { color: #A0A0A0; font-size: 0.9em; text-align: right; }
</style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header" id="chatHeader">
            <div id="header-title">
                <h1>💈 BarberConnect</h1>
                <p>Portal del Cliente</p>
            </div>
            <div class="header-icons">
                <div class="icon-wrapper" id="messagesIconWrapper" title="Ver mensajes">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 10H6v-2h12v2zm0-4H6V6h12v2z"></path></svg>
                    <span class="notification-badge" id="notificationBadge"></span>
                </div>
            </div>
        </div>
        <div class="messages-container" id="messagesContainer">
             <div class="message bot" id="barber-typing-indicator" style="display: none;">
                <div class="typing">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div class="input-container">
            <button class="menu-button" id="menuButton" title="Volver al Menú">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M4 18h16v-2H4v2zm0-5h16v-2H4v2zm0-7v2h16V6H4z"></path></svg>
            </button>
            <input type="text" class="message-input" id="messageInput" placeholder="Escribe un mensaje...">
            <button class="send-button" id="sendButton">➤</button>
        </div>
    </div>

    <input type="file" id="clientPicInput" accept="image/png, image/jpeg" style="display: none;">

    <script>
        const SUPABASE_URL = 'https://olkjevlkqdafbhuiszfz.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9sa2pldmxrcWRhZmJodWlzemZ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkyNzc5ODcsImV4cCI6MjA3NDg1Mzk4N30.5V7LTjITA3szqyNxUy67K0r1IhaB9MpnxSML7IygYcM';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        class ClientChatApp {
            constructor() {
                this.currentFlow = 'init';
                this.barberData = null;
                this.clientProfile = null;
                this.bookingData = {};
                this.profileUpdateData = {}; 
                this.isTyping = false;
                
                this.chatId = null;
                this.chatSubscription = null;
                this.notificationSubscription = null;
                this.qrScanner = null;
                this.paymentDataToConfirm = null;
                this.typingTimeout = null; // <-- NUEVA PROPIEDAD
                
                this.unreadCount = 0;

                this.messagesContainer = document.getElementById('messagesContainer');
                this.messageInput = document.getElementById('messageInput');
                this.sendButton = document.getElementById('sendButton');
                this.chatHeader = document.getElementById('chatHeader');
                this.notificationBadge = document.getElementById('notificationBadge');
                this.messagesIconWrapper = document.getElementById('messagesIconWrapper');
                this.menuButton = document.getElementById('menuButton'); 
                
                this.clientPicInput = null; 

                this.mainMenuButton = `<div class="command-buttons-container" style="margin-top: 15px;"><button class="command-button" data-command="menu">↩️ Volver al Menú</button></div>`;

                this.init();
            }

            async init() {
                this.sendButton.addEventListener('click', () => this.handleSend());
                this.messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') this.handleSend(); });
                this.messageInput.addEventListener('input', () => this.handleTyping()); // <-- NUEVO EVENT LISTENER
                this.messagesContainer.addEventListener('click', this.handleButtonClick.bind(this));
                
                this.messagesIconWrapper.addEventListener('click', () => {
                    if (this.unreadCount > 0) {
                        this.enterLiveChatMode();
                    }
                });
                
                this.menuButton.addEventListener('click', () => this.handleMenuButton());
                
                this.clientPicInput = document.getElementById('clientPicInput');
                this.clientPicInput.addEventListener('change', (event) => this.uploadClientPicture(event));

                await this.checkConnection();
            }
            
            // --- INICIO: LÓGICA PARA NOTIFICACIONES PUSH ---
            /**
             * Pide permiso al usuario para enviar notificaciones y lo suscribe.
             */
            async registerServiceWorker() {
                if (!('Notification' in window) || !('serviceWorker' in navigator)) {
                    this.addBotMessage('<div class="bot-card"><p>❌ Tu navegador no es compatible con las notificaciones.</p></div>');
                    return;
                }

                const currentPermission = Notification.permission;
                if (currentPermission === 'granted') {
                    this.addBotMessage('<div class="bot-card"><p>✅ ¡Las notificaciones ya están activas!</p></div>');
                    return;
                }
                if (currentPermission === 'denied') {
                    this.addBotMessage('<div class="bot-card"><p>🚫 Has bloqueado las notificaciones. Debes activarlas en la configuración de tu navegador.</p></div>');
                    return;
                }

                this.showTyping();
                try {
                    const swRegistration = await navigator.serviceWorker.ready;
                    const permissionResult = await window.Notification.requestPermission();

                    if (permissionResult !== 'granted') {
                        this.hideTyping();
                        this.addBotMessage('<div class="bot-card"><p>⚠️ Permiso denegado. No recibirás notificaciones.</p></div>');
                        return;
                    }

                    // Reemplaza esta clave con tu CLAVE PÚBLICA VAPID
                    const vapidPublicKey = 'BJCOJ2WGEu7_29mhcE56t5zkmkmO2phKSVEELfWjTVe1RtmeZOZ5LWZfMyNWpWo7q7jNhBqezFf5MQFNq9NYSqA'; 
                    const pushSubscription = await swRegistration.pushManager.subscribe({
                        userVisibleOnly: true,
                        applicationServerKey: this.urlBase64ToUint8Array(vapidPublicKey)
                    });

                    await this.savePushSubscription(pushSubscription);
                } catch (error) {
                    console.error("Error durante el registro de notificaciones:", error);
                    this.addBotMessage(`<div class="bot-card"><p>❌ Hubo un error al activar las notificaciones: ${error.message}</p></div>`);
                } finally {
                    this.hideTyping();
                }
            }

            /**
             * Guarda la suscripción en la base de datos para el cliente actual.
             */
            async savePushSubscription(subscription) {
                if (!this.clientProfile || !this.clientProfile.id) {
                    this.addBotMessage('<div class="bot-card"><p>Error crítico: No pude identificarte. Intenta recargar.</p></div>');
                    return;
                }
                
                const { error } = await supabase
                  .from('clients')
                  .update({ push_subscription: subscription })
                  .eq('id', this.clientProfile.id);

                if (error) {
                    console.error("Fallo al guardar la suscripción:", error);
                    this.addBotMessage(`<div class="bot-card"><p>❌ Error en la base de datos al guardar la configuración.<br><small>${error.message}</small></p></div>`);
                } else {
                    this.addBotMessage('<div class="bot-card" style="border-left: 4px solid #4CAF50;"><p><strong>¡Listo! ✅</strong> Recibirás notificaciones de nuevos mensajes.</p></div>');
                }
            }
            
            /**
             * Helper para convertir la clave VAPID.
             */
            urlBase64ToUint8Array(base64String) {
                const padding = '='.repeat((4 - base64String.length % 4) % 4);
                const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
                const rawData = window.atob(base64);
                const outputArray = new Uint8Array(rawData.length);
                for (let i = 0; i < rawData.length; ++i) {
                  outputArray[i] = rawData.charCodeAt(i);
                }
                return outputArray;
            }
            // --- FIN: LÓGICA PARA NOTIFICACIONES PUSH ---

            handleMenuButton() {
                if (this.currentFlow !== 'live_chat') return; 

                if (this.chatSubscription) {
                    this.chatSubscription.unsubscribe();
                    this.chatSubscription = null;
                }
                
                this.messagesContainer.innerHTML = ''; // Limpiar mensajes
                 // Ocultar indicador de escritura si estaba visible
                const typingIndicator = document.getElementById('barber-typing-indicator');
                if (typingIndicator) typingIndicator.style.display = 'none';

                this.menuButton.classList.remove('visible');
                this.showClientMainMenu();
                this.subscribeToNotifications(); // Volver a suscribirse a notificaciones generales
            }

            updateNotificationBadge() {
                if (this.unreadCount > 0) {
                    this.notificationBadge.textContent = this.unreadCount > 9 ? '9+' : this.unreadCount;
                    this.notificationBadge.classList.add('visible');
                } else {
                    this.notificationBadge.classList.remove('visible');
                }
            }

            resetUnreadCount() {
                this.unreadCount = 0;
                this.updateNotificationBadge();
            }

            subscribeToNotifications() {
                if (!this.chatId || this.notificationSubscription) return;

                this.notificationSubscription = supabase
                    .channel(`client_notifications_${this.chatId}`)
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'messages',
                        filter: `chat_id=eq.${this.chatId}`
                    }, (payload) => {
                        if (payload.new.sender_type === 'barber' && this.currentFlow !== 'live_chat') {
                            this.unreadCount++;
                            this.updateNotificationBadge();
                        }
                    })
                    .subscribe();
            }

            async handleButtonClick(event) {
                const button = event.target.closest('.command-button, .edit-icon-button');
                if (!button || button.disabled) return;
                
                const container = button.closest('.command-buttons-container');
                if (container && !button.closest('.return-menu')) {
                   container.querySelectorAll('.command-button').forEach(btn => {
                       btn.disabled = true;
                       // No cambiamos el estilo aquí para que no se vea gris
                       // btn.style.cursor = 'not-allowed';
                       // btn.style.backgroundColor = '#e9ecef'; 
                   });
                }
                
                const command = button.dataset.command;
                
                if(command === '/editar_client_name') {
                    // Procesar directamente sin añadir mensaje de usuario
                    await this.processUserInput(command);
                    return;
                }

                // Añadir mensaje de usuario solo si no es un botón de edición silencioso
                this.addUserMessage(button.textContent.trim());
                await this.processUserInput(command);
            }
            
            // --- NUEVA FUNCIÓN PARA GESTIONAR "ESTÁ ESCRIBIENDO" (CLIENTE) ---
            async handleTyping() {
                // Solo nos interesa si estamos en un chat en vivo
                if (this.currentFlow !== 'live_chat' || !this.chatSubscription) {
                    return;
                }

                // Si ya hay un timeout, lo limpiamos
                if (this.typingTimeout) {
                    clearTimeout(this.typingTimeout);
                }

                try {
                    // Enviamos el evento "typing" al canal del chat
                    this.chatSubscription.broadcast({
                        event: 'typing',
                        sender: 'client' // Identificamos que es el cliente
                    });

                    // Creamos un nuevo timeout. Si el cliente no escribe
                    // en 2 segundos, enviamos "stopped-typing"
                    this.typingTimeout = setTimeout(() => {
                        this.chatSubscription.broadcast({
                            event: 'stopped-typing',
                            sender: 'client'
                        });
                        this.typingTimeout = null;
                    }, 2000);

                } catch (error) {
                    console.error("Error al emitir evento 'typing' (cliente):", error);
                }
            }

            async handleSend() {
                const text = this.messageInput.value.trim();
                if (!text || this.isTyping) return;
                this.messageInput.value = '';
                
                // --- MODIFICACIÓN PARA "ESTÁ ESCRIBIENDO" ---
                // Limpiamos el timeout y enviamos "stopped-typing"
                if (this.typingTimeout) {
                    clearTimeout(this.typingTimeout);
                    this.typingTimeout = null;
                }
                if (this.currentFlow === 'live_chat' && this.chatSubscription) {
                    this.chatSubscription.broadcast({
                        event: 'stopped-typing',
                        sender: 'client' // Identificamos que es el cliente
                    });
                }
                // --- FIN DE LA MODIFICACIÓN ---

                if (this.currentFlow === 'live_chat') {
                    this.sendRealtimeMessage(text);
                } else {
                    this.addUserMessage(text);
                    await this.processUserInput(text.toLowerCase());
                }
            }
            
            async processUserInput(input) {
                // Detener escáner QR si está activo
                if (this.qrScanner) {
                    await this.qrScanner.stop().catch(e => console.log("Scanner already stopped."));
                    this.qrScanner = null;
                }
                
               // Si estamos en chat en vivo, solo procesamos el comando 'menu'
               if (this.currentFlow === 'live_chat') {
                    if (input === 'menu') { 
                        this.handleMenuButton();
                    }
                    // Ignorar cualquier otro input textual ya que se maneja en handleSend
                    return; 
                }

                this.showTyping();
                await new Promise(resolve => setTimeout(resolve, 600));
                this.hideTyping();

                // Comando universal 'menu'
                if (input === 'menu') {
                    this.bookingData = {}; 
                    this.profileUpdateData = {};
                    this.paymentDataToConfirm = null; // Cancelar pago pendiente
                    this.currentFlow = 'main_menu'; // Asegurar el flujo correcto
                    this.showClientMainMenu();
                    return;
                }

                // --- Flujos específicos ---
                if (input.startsWith('seleccionar_barbero:')) {
                    const barberName = input.split(':')[1];
                    this.bookingData.barberName = barberName;
                    await this.showServicesForBooking();
                    return;
                }

                if (this.currentFlow === 'awaiting_code') {
                    await this.handleCodeEntry(input);
                    return; 
                }

                if (this.currentFlow === 'awaiting_phone') {
                    await this.findOrCreateClientByPhone(input);
                    return; 
                }
                
                // Procesar comandos según el flujo actual
                switch (this.currentFlow) {
                    case 'booking_date':
                        await this.handleDateSelection(input);
                        return;
                    case 'booking_time':
                        await this.handleTimeSelection(input);
                        return;
                    case 'booking_confirmation':
                         if (input === 'confirmar_reserva') {
                            await this.confirmAndCreateBooking();
                         } else { // Asumimos 'cancelar_reserva' o cualquier otra cosa
                            this.addBotMessage(`<div class="bot-card"><p>Reserva cancelada.</p></div>`);
                            this.showClientMainMenu();
                         }
                        return;
                    case 'editing_profile_firstname':
                        this.profileUpdateData.firstName = this.capitalizeName(input); // Capitalizar nombre
                        this.addBotMessage(`<div class="bot-card"><p>¡Entendido, ${this.profileUpdateData.firstName}!</p><p>Ahora, por favor, dime tu apellido.</p>${this.mainMenuButton}</div>`);
                        this.currentFlow = 'editing_profile_lastname';
                        return;
                    case 'editing_profile_lastname':
                        this.profileUpdateData.lastName = this.capitalizeName(input); // Capitalizar apellido
                        await this.updateClientProfile();
                        return;
                }
                
                // --- Procesamiento de comandos generales (cuando no está en un flujo específico) ---
                if (input.startsWith('reservar_servicio:')) {
                    const serviceName = input.split(':')[1];
                    // Asegurarse de que bookingData.barberName esté definido
                    if (!this.bookingData.barberName) {
                         this.addBotMessage(`<div class="bot-card"><p>⚠️ Hubo un error. Por favor, vuelve a iniciar la reserva.</p></div>`);
                         this.showClientMainMenu();
                         return;
                    }
                    const barberServices = this.barberData.services[this.bookingData.barberName] || [];
                    this.bookingData.service = barberServices.find(s => s.name === serviceName);
                    
                    if (!this.bookingData.service) {
                         this.addBotMessage(`<div class="bot-card"><p>⚠️ Servicio no encontrado. Por favor, selecciona uno de la lista.</p></div>`);
                         await this.showServicesForBooking(); // Mostrar de nuevo los servicios
                         return;
                    }
                    
                    this.addBotMessage(`<div class="bot-card"><p>Has seleccionado: <strong>${this.bookingData.service.name}</strong> ($${this.bookingData.service.price}).</p><p>Por favor, elige una fecha (p. ej., "hoy", "mañana" o "25/12"):</p>${this.mainMenuButton}</div>`);
                    this.currentFlow = 'booking_date';
                    return;
                }

                // Manejo de comandos principales cuando no está en otro flujo
                switch (input) {
                    case '/servicios': await this.showServices(); break;
                    case '/horario': await this.showAvailability(); break;
                    case '/reservar': await this.startBookingFlow(); break;
                    case '/hablar': await this.enterLiveChatMode(); break;
                    case '/miperfil': await this.startProfileEditFlow(); break;
                    case '/pagar_qr': await this.startQRScanner(); break;
                    case '/suscribirse_notificaciones': await this.registerServiceWorker(); break; // Manejar el nuevo comando
                    case '/editar_client_name': // Comando desde el botón de editar perfil
                        this.addBotMessage(`<div class="bot-card"><p>Tu nombre actual es <strong>${this.clientProfile.first_name}</strong>.</p><p>Por favor, escribe tu nuevo nombre.</p>${this.mainMenuButton}</div>`);
                        this.currentFlow = 'editing_profile_firstname';
                        break;
                    // Ya no necesitamos 'menu' aquí, se maneja al principio
                    default:
                        // Solo mostrar este mensaje si no estamos en un flujo de espera
                        if (!['awaiting_code', 'awaiting_phone'].includes(this.currentFlow)) {
                            this.addBotMessage(`<div class="bot-card"><p>No entendí eso. Puedes usar los botones del menú.</p></div>`);
                            this.showClientMainMenu();
                        }
                        break;
                }
            }

            async startQRScanner() {
                const scannerHTML = `
                <div class="bot-card">
                    <h3>Escanear Código QR</h3>
                    <p>Apunta la cámara al código QR que te muestre tu barbero.</p>
                    <div id="qr-reader" style="width: 100%; max-width: 300px; margin: 10px auto;"></div>
                    <div class="command-buttons-container" style="margin-top: 15px;">
                        <button class="command-button return full-width" data-command="menu">Cancelar</button>
                    </div>
                </div>`;
                this.addBotMessage(scannerHTML);

                await new Promise(resolve => setTimeout(resolve, 100)); // Esperar renderizado

                try {
                    const html5QrCode = new Html5Qrcode("qr-reader");
                    this.qrScanner = html5QrCode; 
                    
                    const qrCodeSuccessCallback = async (decodedText, decodedResult) => {
                        console.log(`Scan result: ${decodedText}`);
                        if (this.qrScanner) {
                            try {
                                await this.qrScanner.stop();
                                console.log("Scanner stopped successfully.");
                            } catch (stopErr) {
                                console.warn("Error stopping scanner (might be already stopped):", stopErr);
                            } finally {
                                this.qrScanner = null; 
                                document.getElementById('qr-reader').innerHTML = ''; // Limpiar el contenedor
                                await this.handleScannedQRCode(decodedText);
                            }
                        }
                    };
                    
                    const config = { fps: 10, qrbox: { width: 200, height: 200 } };
                    
                    // Intentar iniciar con la cámara trasera
                    await html5QrCode.start({ facingMode: "environment" }, config, qrCodeSuccessCallback);
                    
                } catch (err) {
                    console.error("Error al iniciar el escaner QR:", err);
                    this.addBotMessage(`<div class="bot-card"><p>❌ No se pudo iniciar la cámara. Asegúrate de dar los permisos necesarios y que no esté siendo usada por otra app.</p></div>`);
                    this.showClientMainMenu(); // Volver al menú si falla
                }
            }


            async handleScannedQRCode(qrDataString) {
                try {
                    const paymentData = JSON.parse(qrDataString);
                    // Validar campos básicos
                    if (!paymentData || typeof paymentData !== 'object' || !paymentData.barber_id || !paymentData.amount || !paymentData.description || !paymentData.performer) {
                        throw new Error("Formato de datos QR inválido.");
                    }
                    
                    if (paymentData.barber_id !== this.barberData.id) {
                        this.addBotMessage(`<div class="bot-card"><p>⚠️ <strong>Error:</strong> Este código QR no pertenece a ${this.barberData.barber_shop_name}.</p></div>`);
                        this.showClientMainMenu();
                        return;
                    }

                    this.paymentDataToConfirm = paymentData;

                    const confirmationHTML = `
                    <div class="bot-card">
                        <h3>Confirmar Pago</h3>
                        <p>Estás a punto de registrar un pago para <strong>${this.barberData.barber_shop_name}</strong>.</p>
                        <ul>
                            <li><strong>Monto:</strong> ${parseFloat(paymentData.amount).toFixed(2)} Bs.</li>
                            <li><strong>Por:</strong> ${paymentData.description}</li>
                            <li><strong>Atendido por:</strong> ${paymentData.performer}</li>
                        </ul>
                        <p class="helper-text" style="color: #FFB300;"><strong>Importante:</strong> Esto solo registra la transacción en la app. Recuerda realizar el pago real (efectivo, transferencia, etc.) directamente al barbero.</p>
                        <div class="command-buttons-container">
                            <button class="command-button confirm" onclick="app.confirmAndProcessPayment()">✅ Sí, Registrar Pago</button>
                            <button class="command-button cancel" data-command="menu">❌ Cancelar</button>
                        </div>
                    </div>`;
                    this.addBotMessage(confirmationHTML);
                    this.currentFlow = 'confirming_payment'; // Nuevo flujo

                } catch (error) {
                    console.error("Error procesando QR:", error);
                    this.addBotMessage(`<div class="bot-card"><p>❌ <strong>Código QR no válido.</strong> No pude leer la información de pago. Asegúrate de que sea un código generado por BarberConnect.</p></div>`);
                    this.showClientMainMenu();
                }
            }

            // Cambiamos el nombre del método en el HTML onclick
            async confirmAndProcessPayment() {
                 // Deshabilitar botones para evitar doble clic
                const confirmButton = document.querySelector('.command-button[onclick="app.confirmAndProcessPayment()"]');
                const cancelButton = document.querySelector('.command-button[data-command="menu"]');
                if (confirmButton) confirmButton.disabled = true;
                if (cancelButton) cancelButton.disabled = true;

                if (!this.paymentDataToConfirm) return;
                
                // No añadir mensaje de usuario para esta acción
                // this.addUserMessage("Sí, Registrar Pago"); 
                this.showTyping();

                const { amount, description, performer } = this.paymentDataToConfirm;

                // 1. Registrar la transacción
                const { error: transactionError } = await supabase
                    .from('transactions')
                    .insert({
                        barber_id: this.barberData.id,
                        client_id: this.clientProfile.id,
                        amount: parseFloat(amount), // Asegurar que es número
                        description: description,
                        barber_name_performer: performer
                    });

                if (transactionError) {
                    this.hideTyping();
                    this.addBotMessage(`<div class="bot-card" style="border-color: #F44336;"><p>❌ Hubo un error al registrar la transacción.</p><p class="helper-text">${transactionError.message}</p></div>`);
                    console.error("Error inserting transaction:", transactionError);
                    this.showClientMainMenu(); // O intentar de nuevo? Mejor al menú.
                    return; // Detener ejecución
                }

                // 2. Actualizar el saldo del barbero (si la transacción fue exitosa)
                const { error: rpcError } = await supabase.rpc('increment_barber_balance', {
                    barber_id_in: this.barberData.id,
                    amount_in: parseFloat(amount) // Asegurar que es número
                });

                this.hideTyping(); // Ocultar typing DESPUÉS de ambas operaciones

                if (rpcError) {
                    // La transacción se registró, pero el saldo no se actualizó (esto es menos crítico para el cliente)
                    this.addBotMessage(`<div class="bot-card" style="border-color: #FF9800;"><p>⚠️ Pago registrado, pero hubo un problema al actualizar el saldo del barbero. Notifícale por si acaso.</p><p class="helper-text">${rpcError.message}</p></div>`);
                    console.error("Error calling RPC:", rpcError);
                } else {
                    // Todo salió bien
                    this.addBotMessage(`<div class="bot-card" style="border-color: #4CAF50;"><p>✅ <strong>¡Pago registrado con éxito!</strong> Gracias.</p></div>`);
                }
                
                this.paymentDataToConfirm = null; // Limpiar datos de pago
                this.currentFlow = 'main_menu'; // Volver al flujo principal
                setTimeout(() => this.showClientMainMenu(), 2500); // Dar tiempo para leer el mensaje
            }
            
            async startProfileEditFlow() {
                this.showTyping();
                
                // Refrescar perfil desde la BD
                const { data: profile, error } = await supabase
                    .from('clients')
                    .select('*, avatar_url') // Asegúrate de incluir avatar_url
                    .eq('id', this.clientProfile.id)
                    .single();
                
                this.hideTyping();
                
                if(error || !profile) {
                    console.error("Error fetching profile:", error);
                    this.addBotMessage('<div class="bot-card"><p>❌ No pude cargar tu perfil actualizado. Intenta de nuevo.</p></div>');
                    this.showClientMainMenu(); // Volver al menú si falla
                    return;
                }
                
                this.clientProfile = profile; // Actualizar perfil local
                
                let avatarHTML = '';
                if (profile.avatar_url) {
                    // Añadir un timestamp para evitar caché si la imagen acaba de cambiar
                    avatarHTML = `<div class="profile-avatar"><img src="${profile.avatar_url}?t=${new Date().getTime()}" alt="Foto de Perfil"></div>`;
                } else {
                    const initial = profile.first_name ? profile.first_name.charAt(0).toUpperCase() : 'C';
                    avatarHTML = `<div class="profile-avatar"><span>${initial}</span></div>`;
                }

                let photoButtonsHTML = '';
                if (profile.avatar_url) {
                    photoButtonsHTML = `
                        <button class="command-button" onclick="app.triggerClientFileUpload()">✏️ Editar Foto</button>
                        <button class="command-button cancel" onclick="app.deleteClientPicture()">🗑️ Eliminar Foto</button>
                    `;
                } else {
                    photoButtonsHTML = `
                        <button class="command-button full-width confirm" onclick="app.triggerClientFileUpload()">📸 Subir Foto de Perfil</button>
                    `;
                }

                const profileHTML = `
                <div class="bot-card">
                    <h3>👤 Mi Perfil</h3>
                    <div class="profile-avatar-wrapper">${avatarHTML}</div>
            
                    <div class="command-buttons-container" style="margin-bottom: 15px; grid-template-columns: ${profile.avatar_url ? '1fr 1fr' : '1fr'};">
                        ${photoButtonsHTML}
                    </div>
            
                    <ul>
                        <li style="display: flex; align-items: center;">
                            <span class="item-name">Nombre:</span>
                            <span class="item-detail" style="margin-left: 1rem; text-align: left; flex-grow: 1;">${profile.first_name} ${profile.last_name}</span>
                            <button class="edit-icon-button" data-command="/editar_client_name" style="margin-left: 10px;" title="Editar nombre">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></svg>
                            </button>
                        </li>
                        <li><span class="item-name">Teléfono:</span><span class="item-detail">${profile.phone_number}</span></li>
                        </ul>
            
                    <div class="command-buttons-container" style="margin-top: 15px;">
                        <button class="command-button full-width return-menu" data-command="menu">↩️ Volver al Menú</button>
                    </div>
                </div>`;
                
                this.addBotMessage(profileHTML);
                this.currentFlow = 'profile_menu'; // Estado para saber que estamos viendo el perfil
            }


            async updateClientProfile() {
                this.showTyping();
                const { firstName, lastName } = this.profileUpdateData;

                 // Validar que los nombres no estén vacíos
                 if (!firstName || !lastName || firstName.trim() === '' || lastName.trim() === '') {
                    this.hideTyping();
                    this.addBotMessage(`<div class="bot-card"><p>❌ El nombre y el apellido no pueden estar vacíos.</p>${this.mainMenuButton}</div>`);
                    this.currentFlow = 'profile_menu'; // Volver al menú de perfil
                    setTimeout(() => this.startProfileEditFlow(), 1500); // Mostrar perfil de nuevo
                    return;
                 }


                const { data: updatedClient, error } = await supabase
                    .from('clients')
                    .update({ 
                        first_name: this.capitalizeName(firstName.trim()), 
                        last_name: this.capitalizeName(lastName.trim()) 
                     })
                    .eq('id', this.clientProfile.id)
                    .select('*, avatar_url') // Asegurarse de seleccionar avatar_url
                    .single();

                this.hideTyping();

                if (error) {
                    console.error("Error updating profile:", error);
                    this.addBotMessage(`<div class="bot-card"><p>❌ Hubo un error al actualizar tu perfil.</p><p class="helper-text">${error.message}</p>${this.mainMenuButton}</div>`);
                } else {
                    this.clientProfile = updatedClient; // Actualizar perfil local
                    this.addBotMessage(`<div class="bot-card"><p>✅ ¡Perfecto, ${updatedClient.first_name}! Tu perfil ha sido actualizado.</p></div>`);
                }

                this.profileUpdateData = {}; // Limpiar datos temporales
                this.currentFlow = 'profile_menu'; // Volver al estado de ver perfil
                setTimeout(() => this.startProfileEditFlow(), 1500); // Mostrar perfil actualizado
            }
            
            triggerClientFileUpload() {
                this.clientPicInput.click();
            }
            
            async uploadClientPicture(event) {
                const file = event.target.files[0];
                if (!file) return;

                const fileTypes = ['image/png', 'image/jpeg'];
                if (!fileTypes.includes(file.type)) {
                    this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;"><p>❌ <strong>Formato no válido.</strong><br>Por favor, sube una imagen PNG o JPG.</p></div>`);
                    return;
                }
                if (file.size > 2 * 1024 * 1024) { // Límite de 2MB
                    this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;"><p>❌ <strong>Imagen muy grande.</strong><br>El límite es de 2 MB.</p></div>`);
                    return;
                }
                
                this.addBotMessage('<div class="bot-card"><p>Subiendo foto, por favor espera... ⏳</p></div>');
                this.showTyping();
                
                const bucketName = 'client_pictures'; // Asegúrate que este bucket exista y tenga políticas RLS adecuadas
                const filePath = `${this.clientProfile.id}/profile_${Date.now()}.png`; // Nombre único para evitar caché agresiva

                try {
                    // Subir la nueva imagen
                    const { data: uploadData, error: uploadError } = await supabase.storage
                        .from(bucketName)
                        .upload(filePath, file, {
                            cacheControl: '3600',
                            upsert: false, // No sobrescribir, generar nombre único
                        });

                    if (uploadError) {
                        console.error("Error en Subida (Storage):", uploadError);
                        throw new Error(`Error de Storage: ${uploadError.message}`);
                    }

                    // Obtener la URL pública de la NUEVA imagen
                    const { data: urlData } = supabase.storage
                        .from(bucketName)
                        .getPublicUrl(filePath); // Usar el nuevo filePath
                        
                    const newPublicURL = urlData.publicUrl;

                    // Actualizar el perfil del cliente con la NUEVA URL
                    const { data: updatedProfile, error: dbError } = await supabase
                        .from('clients')
                        .update({ avatar_url: newPublicURL })
                        .eq('id', this.clientProfile.id)
                        .select('*, avatar_url') // Seleccionar de nuevo para confirmar
                        .single();

                    if (dbError) {
                        console.error("Error en Actualización (DB):", dbError);
                        // Intentar borrar la imagen subida si la DB falla
                        await supabase.storage.from(bucketName).remove([filePath]);
                        throw new Error(`Error de Base de Datos: ${dbError.message}`);
                    }

                    // Si había una foto anterior, borrarla (opcional, pero buena práctica)
                    if (this.clientProfile.avatar_url) {
                        const oldFilePath = this.clientProfile.avatar_url.split(`${bucketName}/`)[1].split('?')[0]; // Extraer path antiguo
                         if (oldFilePath && oldFilePath !== filePath) { // Evitar borrar la que acabamos de subir
                             await supabase.storage.from(bucketName).remove([oldFilePath]);
                         }
                    }

                    this.clientProfile = updatedProfile; // Actualizar perfil local
                    this.addBotMessage('<div class="bot-card" style="border-left: 4px solid #4CAF50;"><p>✅ ¡Foto de perfil actualizada con éxito!</p></div>');
                    
                } catch (error) {
                    console.error("Error completo subiendo la foto:", error);
                    this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;">
                        <p><strong>❌ Hubo un error al subir tu foto:</strong><br><small>${error.message}</small></p>
                        <p class="helper-text">Por favor, inténtalo de nuevo.</p>
                    </div>`);
                } finally {
                    this.hideTyping();
                    this.clientPicInput.value = ''; // Resetear input de archivo
                    await this.startProfileEditFlow(); // Mostrar perfil actualizado
                }
            }
            
            async deleteClientPicture() {
                if (!this.clientProfile.avatar_url) {
                     this.addBotMessage('<div class="bot-card"><p>No tienes una foto de perfil para eliminar.</p></div>');
                     return;
                }
                if (!confirm("¿Estás seguro de que quieres eliminar tu foto de perfil?")) return;

                this.addBotMessage('<div class="bot-card"><p>Eliminando foto...</p></div>');
                this.showTyping();
                
                const bucketName = 'client_pictures';
                // Extraer el path del archivo de la URL guardada
                const filePath = this.clientProfile.avatar_url.split(`${bucketName}/`)[1].split('?')[0]; // Quita parámetros como ?t=...

                try {
                    // 1. Borrar el archivo de Storage
                    const { error: removeError } = await supabase.storage
                        .from(bucketName)
                        .remove([filePath]);
                    
                    // Ignorar error si el archivo ya no existe, pero loguear otros errores
                    if (removeError && removeError.message !== 'The resource was not found') {
                         console.error("Error borrando de Storage:", removeError);
                         throw new Error(`Error de Storage: ${removeError.message}`);
                    }

                    // 2. Actualizar la base de datos a null
                    const { data: updatedProfile, error: dbError } = await supabase
                        .from('clients')
                        .update({ avatar_url: null })
                        .eq('id', this.clientProfile.id)
                        .select('*, avatar_url') // Volver a seleccionar
                        .single();

                    if (dbError) {
                        console.error("Error actualizando DB:", dbError);
                        throw new Error(`Error de Base de Datos: ${dbError.message}`);
                    }

                    this.clientProfile = updatedProfile; // Actualizar perfil local
                    this.addBotMessage('<div class="bot-card" style="border-left: 4px solid #4CAF50;"><p>✅ Foto eliminada correctamente.</p></div>');

                } catch (error) {
                    console.error("Error eliminando la foto:", error);
                    this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;">
                        <p><strong>❌ Hubo un error al eliminar tu foto:</strong><br><small>${error.message}</small></p>
                    </div>`);
                } finally {
                    this.hideTyping();
                    await this.startProfileEditFlow(); // Mostrar perfil actualizado
                }
            }


            capitalizeName(name) {
                if (!name) return '';
                return name.toLowerCase().split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
            }

            parseDateInput(input) {
                const now = new Date();
                now.setHours(0, 0, 0, 0); // Comparar solo fechas

                input = input.toLowerCase().trim();

                if (input === 'hoy') return now;
                if (input === 'mañana') {
                    const tomorrow = new Date(now);
                    tomorrow.setDate(now.getDate() + 1);
                    return tomorrow;
                }
                // Intentar formato DD/MM o DD-MM
                const parts = input.match(/^(\d{1,2})[\/\-](\d{1,2})$/);
                if (parts) {
                    const day = parseInt(parts[1], 10);
                    const month = parseInt(parts[2], 10) - 1; // Meses son 0-indexados
                    const currentYear = now.getFullYear();
                    
                    // Crear fecha tentativa para este año
                    const dateThisYear = new Date(currentYear, month, day);
                    dateThisYear.setHours(0,0,0,0); // Asegurar hora 00:00:00

                    // Verificar si la fecha es válida (ej: 31/02 no es válido)
                     if (dateThisYear.getDate() !== day || dateThisYear.getMonth() !== month) {
                         return null; // Fecha inválida
                     }

                    // Si la fecha ya pasó este año, asumir el próximo año
                    if (dateThisYear < now) {
                        const dateNextYear = new Date(currentYear + 1, month, day);
                        dateNextYear.setHours(0,0,0,0);
                         // Verificar validez también para el próximo año (año bisiesto)
                         if (dateNextYear.getDate() !== day || dateNextYear.getMonth() !== month) {
                             return null;
                         }
                        return dateNextYear;
                    } else {
                        return dateThisYear;
                    }
                }
                // Añadir más formatos si es necesario (ej: DD/MM/YYYY)
                 const fullParts = input.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
                 if (fullParts) {
                    const day = parseInt(fullParts[1], 10);
                    const month = parseInt(fullParts[2], 10) - 1;
                    const year = parseInt(fullParts[3], 10);
                    const date = new Date(year, month, day);
                    date.setHours(0,0,0,0);
                     if (date.getDate() === day && date.getMonth() === month && date.getFullYear() === year) {
                         return date;
                     }
                 }

                return null; // Formato no reconocido
            }

            async handleDateSelection(input) {
                const selectedDate = this.parseDateInput(input);

                // Verificar si la fecha es válida Y no es anterior a hoy
                if (!selectedDate || selectedDate < new Date().setHours(0, 0, 0, 0)) {
                    this.addBotMessage(`<div class="bot-card"><p>❌ Fecha no válida o ya pasó. Inténtalo de nuevo (p. ej., "hoy", "mañana", "25/12" o "15/01/${new Date().getFullYear()+1}").</p>${this.mainMenuButton}</div>`);
                    // Mantener el flujo en 'booking_date'
                    return;
                }

                this.bookingData.date = selectedDate;
                
                this.showTyping();
                await this.showAvailableTimesForDate(selectedDate);
                this.hideTyping(); // Ocultar después de mostrar los tiempos
            }
            
            async showAvailableTimesForDate(date) {
                const dayMapping = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
                const dayKey = dayMapping[date.getDay()];
                
                // Asegurarse de que bookingData.barberName existe
                if (!this.bookingData.barberName || !this.barberData.availability[this.bookingData.barberName]) {
                    this.addBotMessage(`<div class="bot-card"><p>⚠️ Error interno: No se pudo encontrar el horario del barbero. Vuelve a empezar.</p>${this.mainMenuButton}</div>`);
                    this.showClientMainMenu();
                    return;
                }
                
                const barberSchedule = this.barberData.availability[this.bookingData.barberName][dayKey] || [];

                if (barberSchedule.length === 0) {
                    this.addBotMessage(`<div class="bot-card"><p>❌ ${this.bookingData.barberName} no trabaja el ${date.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long' })}. Por favor, elige otra fecha.</p>${this.mainMenuButton}</div>`);
                    this.currentFlow = 'booking_date'; // Volver a pedir fecha
                    return;
                }

                // Definir inicio y fin del día para la consulta
                const startOfDay = new Date(date); startOfDay.setHours(0, 0, 0, 0);
                const endOfDay = new Date(date); endOfDay.setHours(23, 59, 59, 999);

                // Consultar reservas existentes para ESE barbero en ESA fecha
                const { data: existingBookings, error } = await supabase
                    .from('bookings')
                    .select('booking_date')
                    .eq('barber_id', this.barberData.id) // ID del negocio
                    .eq('barber_name', this.bookingData.barberName) // Nombre del barbero específico
                    .in('status', ['pending', 'confirmed']) // Solo reservas activas
                    .gte('booking_date', startOfDay.toISOString())
                    .lte('booking_date', endOfDay.toISOString());

                if (error) {
                    console.error("Error fetching existing bookings:", error);
                    this.addBotMessage(`<div class="bot-card"><p>⚠️ Error al verificar disponibilidad. Inténtalo más tarde.</p>${this.mainMenuButton}</div>`);
                    this.showClientMainMenu();
                    return;
                }
                
                const bookedHours = existingBookings.map(b => new Date(b.booking_date).getHours());
                
                // Filtrar horas disponibles del horario base
                let availableHours = barberSchedule.filter(hour => !bookedHours.includes(hour));
                
                // Si es hoy, filtrar horas que ya pasaron
                const now = new Date();
                const isToday = date.toDateString() === now.toDateString();
                if (isToday) {
                    availableHours = availableHours.filter(hour => hour > now.getHours());
                }
                
                // Ordenar las horas disponibles
                availableHours.sort((a, b) => a - b);

                if (availableHours.length === 0) {
                    this.addBotMessage(`<div class="bot-card"><p>❌ <strong>No hay cupos disponibles</strong> para ${this.bookingData.barberName} el ${date.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long' })}.</p><p>Por favor, elige otra fecha.</p>${this.mainMenuButton}</div>`);
                    this.currentFlow = 'booking_date'; // Volver a pedir fecha
                    return;
                }

                // Crear botones para las horas disponibles
                const timeButtons = availableHours.map(hour => 
                    `<button class="command-button" data-command="reservar_hora:${hour}:00">${String(hour).padStart(2, '0')}:00</button>`
                ).join('');
                
                this.addBotMessage(`<div class="bot-card">
                    <h3>⏰ Horas disponibles para ${this.bookingData.barberName}</h3>
                    <p><strong>Fecha:</strong> ${date.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long' })}</p>
                    <div class="command-buttons-container">${timeButtons}
                    <button class="command-button full-width return-menu" data-command="menu">↩️ Volver al Menú</button></div>
                </div>`);
                this.currentFlow = 'booking_time'; // Avanzar al siguiente paso
            }


            async handleTimeSelection(input) {
                if (!input.startsWith('reservar_hora:')) {
                    this.addBotMessage(`<div class="bot-card"><p>Selección no válida. Por favor, usa uno de los botones de hora.</p>${this.mainMenuButton}</div>`);
                    // Re-mostrar las horas disponibles para la fecha ya seleccionada
                    await this.showAvailableTimesForDate(this.bookingData.date); 
                    return;
                }

                const timeParts = input.split(':');
                const hour = parseInt(timeParts[1], 10);
                const minute = parseInt(timeParts[2], 10);

                // Crear el objeto Date final para la reserva
                const finalTimestamp = new Date(this.bookingData.date);
                finalTimestamp.setHours(hour, minute, 0, 0); 
                this.bookingData.finalTimestamp = finalTimestamp;
                
                // Mostrar resumen para confirmación
                const confirmationHTML = `
                <div class="bot-card">
                    <h3>Confirmar Reserva</h3>
                    <p>Por favor, revisa los detalles de tu cita:</p>
                    <ul>
                        <li><strong>Barbero:</strong> ${this.bookingData.barberName}</li>
                        <li><strong>Servicio:</strong> ${this.bookingData.service.name}</li>
                        <li><strong>Precio:</strong> ${this.bookingData.service.price} Bs.</li>
                        <li><strong>Fecha:</strong> ${finalTimestamp.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' })}</li>
                        <li><strong>Hora:</strong> ${finalTimestamp.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', hour12: true })}</li>
                    </ul>
                    <div class="command-buttons-container">
                        <button class="command-button confirm" data-command="confirmar_reserva">✅ Confirmar Reserva</button>
                        <button class="command-button cancel" data-command="cancelar_reserva">❌ Cancelar</button>
                    </div>
                </div>`;
                this.addBotMessage(confirmationHTML);
                this.currentFlow = 'booking_confirmation';
            }
            
            async confirmAndCreateBooking() {
                // Deshabilitar botones para evitar doble clic
                const confirmButton = document.querySelector('.command-button[data-command="confirmar_reserva"]');
                const cancelButton = document.querySelector('.command-button[data-command="cancelar_reserva"]');
                if (confirmButton) confirmButton.disabled = true;
                if (cancelButton) cancelButton.disabled = true;

                this.showTyping();
                
                // Verificar que todos los datos necesarios están presentes
                if (!this.barberData || !this.clientProfile || !this.bookingData.service || !this.bookingData.finalTimestamp || !this.bookingData.barberName) {
                     this.hideTyping();
                     this.addBotMessage(`<div class="bot-card"><p>⚠️ Error: Faltan datos para la reserva. Por favor, inténtalo de nuevo desde el menú.</p>${this.mainMenuButton}</div>`);
                     this.bookingData = {}; // Limpiar datos
                     this.currentFlow = 'main_menu';
                     setTimeout(() => this.showClientMainMenu(), 2000);
                     return;
                }

                const payload = { 
                    barber_id: this.barberData.id, 
                    client_id: this.clientProfile.id, 
                    service_name: this.bookingData.service.name, 
                    price: this.bookingData.service.price, 
                    booking_date: this.bookingData.finalTimestamp.toISOString(), // Guardar en UTC
                    status: 'confirmed', // O 'pending' si requiere aprobación
                    barber_name: this.bookingData.barberName // Nombre del barbero que atenderá
                };

                const { error } = await supabase.from('bookings').insert(payload);
                
                this.hideTyping();
                
                if (error) {
                    console.error('Error al crear la reserva en Supabase:', error);
                     // Verificar si es un error de horario duplicado (requiere una función/trigger en Supabase)
                     if (error.message.includes('booking_conflict')) { // Asumiendo un mensaje de error específico
                         this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #FF9800;">
                            <p>⚠️ ¡Uy! Parece que alguien reservó esa hora justo ahora.</p>
                            <p>Por favor, selecciona otra hora.</p>
                         </div>`);
                         // Volver a mostrar las horas disponibles para esa fecha
                         this.currentFlow = 'booking_time'; 
                         await this.showAvailableTimesForDate(this.bookingData.date);
                     } else {
                         // Otro tipo de error
                        this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;">
                            <p>❌ Lo siento, ocurrió un error al crear tu reserva.</p>
                            <p class="helper-text">${error.message}</p>
                            ${this.mainMenuButton}
                        </div>`);
                        this.bookingData = {}; // Limpiar datos de reserva
                        this.currentFlow = 'main_menu';
                        setTimeout(() => this.showClientMainMenu(), 2000);
                     }
                } else {
                    // ¡Éxito!
                    this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #4CAF50;">
                        <h3>¡Reserva Confirmada! ✅</h3>
                        <p>Tu cita para un <strong>${this.bookingData.service.name}</strong> con <strong>${this.bookingData.barberName}</strong> ha sido agendada con éxito.</p>
                        <p>Te esperamos el <strong>${this.bookingData.finalTimestamp.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' })}</strong> a las <strong>${this.bookingData.finalTimestamp.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}</strong>.</p>
                    </div>`);
                    this.bookingData = {}; // Limpiar datos de reserva
                    this.currentFlow = 'main_menu';
                    setTimeout(() => this.showClientMainMenu(), 3000); // Volver al menú después de unos segundos
                }
            }
            
            async startBookingFlow() {
                // Refrescar datos del barbero (horarios, servicios)
                await this.loadBarberData(this.barberData.public_code, false); 
                
                const barbers = Object.keys(this.barberData.availability || {});
                
                if (barbers.length === 0) {
                     this.addBotMessage(`<div class="bot-card"><p>Lo siento, parece que ${this.barberData.barber_shop_name} no tiene barberos configurados en este momento.</p>${this.mainMenuButton}</div>`);
                     return;
                }
                
                if (barbers.length === 1) {
                    // Si solo hay un barbero, seleccionarlo automáticamente
                    this.bookingData.barberName = barbers[0];
                    await this.showServicesForBooking();
                } else {
                    // Si hay varios, mostrar botones para elegir
                    const barberButtons = barbers.map(name => 
                        `<button class="command-button" data-command="seleccionar_barbero:${name}">${name}</button>`
                    ).join('');
                    
                    this.addBotMessage(`<div class="bot-card">
                        <h3>Iniciemos tu reserva</h3>
                        <p>¿Con cuál de nuestros barberos te gustaría agendar?</p>
                        <div class="command-buttons-container">${barberButtons}${this.mainMenuButton}</div>
                    </div>`);
                    this.currentFlow = 'booking_select_barber';
                }
            }

            async showServicesForBooking() {
                const barberName = this.bookingData.barberName;
                const barberServices = this.barberData.services[barberName] || [];

                if (barberServices.length === 0) {
                    this.addBotMessage(`<div class="bot-card"><p>Lo siento, ${barberName} no tiene servicios disponibles en este momento.</p>${this.mainMenuButton}</div>`);
                    this.currentFlow = 'main_menu'; // Volver al menú
                    return;
                }
                
                const serviceButtons = barberServices.map(service => 
                    `<button class="command-button" data-command="reservar_servicio:${service.name}">${service.name} (${service.price} Bs.)</button>`
                ).join('');
                
                this.addBotMessage(`<div class="bot-card">
                    <h3>Servicios de ${barberName}</h3>
                    <p>Por favor, selecciona el servicio que deseas:</p>
                    <div class="command-buttons-container">${serviceButtons}${this.mainMenuButton}</div>
                </div>`);
                this.currentFlow = 'booking_select_service';
            }


            async checkConnection() {
                this.showTyping();
                const clientId = localStorage.getItem('clientId');
                const barberCode = this.getBarberCodeFromURL();

                if (!barberCode) {
                    this.hideTyping();
                    this.addBotMessage('<div class="bot-card"><p>❌ <strong>Error:</strong> No se encontró un código de barbero en la URL. Asegúrate de usar el enlace proporcionado por tu barbería.</p></div>');
                    return;
                }
                
                await this.loadBarberData(barberCode);

                if (!clientId) {
                    this.hideTyping();
                    this.addBotMessage(`<div class="bot-card"><p>¡Hola! 👋 Para conectarte con <strong>${this.barberData.barber_shop_name}</strong>, necesito tu número de teléfono (solo números, ej: 04121234567).</p></div>`);
                    this.currentFlow = 'awaiting_phone';
                } else {
                    await this.loadClientProfile(clientId);
                }
            }

            getBarberCodeFromURL() {
                const params = new URLSearchParams(window.location.search);
                return params.get('c'); // Asumiendo que la URL es ?c=CODIGO
            }
            
            async loadBarberData(code, showWelcome = true) {
                const { data, error } = await supabase
                    .from('barbers')
                    .select('id, barber_shop_name, services, availability, avatar_url, public_code') // Incluir public_code
                    .eq('public_code', code)
                    .single();

                if (error || !data) {
                    this.hideTyping();
                    this.addBotMessage('<div class="bot-card"><p>❌ <strong>Error:</strong> El código del barbero no es válido o no existe.</p></div>');
                    throw new Error("Barber not found.");
                }
                
                this.barberData = data;
                
                // Actualizar el Header
                document.querySelector('#header-title h1').textContent = this.barberData.barber_shop_name;
                document.querySelector('#header-title p').textContent = 'Asistente de Citas';
                
                // Añadir foto de perfil del barbero si existe
                if (this.barberData.avatar_url) {
                    const picContainer = document.createElement('div');
                    picContainer.className = 'profile-picture-container';
                    picContainer.innerHTML = `<img src="${this.barberData.avatar_url}" alt="Foto de ${this.barberData.barber_shop_name}" class="barber-profile-pic">`;
                    this.chatHeader.prepend(picContainer);
                }

                if(showWelcome) {
                    this.addBotMessage(`<div class="bot-card"><p>¡Conectado con <strong>${this.barberData.barber_shop_name}</strong>! 💈</p><p>Verificando tu identidad...</p></div>`);
                }
            }
            
            async loadClientProfile(clientId) {
                const { data: client, error } = await supabase
                    .from('clients')
                    .select('*')
                    .eq('id', clientId)
                    .single();
                
                this.hideTyping();
                
                if (error || !client) {
                    localStorage.removeItem('clientId');
                    this.addBotMessage(`<div class="bot-card"><p>⚠️ No pudimos encontrar tu perfil. Por favor, ingresa tu número de teléfono de nuevo.</p></div>`);
                    this.currentFlow = 'awaiting_phone';
                    return;
                }

                this.clientProfile = client;
                
                // --- Cargar el Chat ID ---
                const { data: chat, error: chatError } = await supabase
                    .from('chats')
                    .select('id')
                    .eq('barber_id', this.barberData.id)
                    .eq('client_id', this.clientProfile.id)
                    .single();
                
                if (chatError || !chat) {
                    console.warn("No se encontró chat, se creará uno nuevo al chatear.", chatError);
                    // No es un error fatal, se creará el chat en enterLiveChatMode si es necesario
                } else {
                    this.chatId = chat.id;
                    this.subscribeToNotifications(); // Suscribirse a notificaciones
                }

                this.addBotMessage(`<div class="bot-card"><p>¡Hola de nuevo, <strong>${this.clientProfile.first_name}</strong>! 👋</p></div>`);
                this.showClientMainMenu();
            }

            async findOrCreateClientByPhone(phone) {
                // Validar teléfono (simple)
                if (!/^\d{10,12}$/.test(phone)) {
                    this.addBotMessage(`<div class="bot-card"><p>❌ El número de teléfono parece inválido. Por favor, ingrésalo de nuevo (solo números, 10-12 dígitos).</p>${this.mainMenuButton}</div>`);
                    return; // Mantiene el flujo en 'awaiting_phone'
                }
                
                this.showTyping();
                
                // 1. Intentar encontrar al cliente por el teléfono
                const { data: existingClient, error: findError } = await supabase
                    .from('clients')
                    .select('*')
                    .eq('phone_number', phone)
                    .single();

                if (findError && findError.code !== 'PGRST116') { // PGRST116 = 0 filas
                    this.hideTyping();
                    this.addBotMessage(`<div class="bot-card"><p>❌ Error al buscar tu perfil: ${findError.message}.</p></div>`);
                    return;
                }
                
                if (existingClient) {
                    // --- Cliente Encontrado ---
                    this.hideTyping();
                    this.clientProfile = existingClient;
                    localStorage.setItem('clientId', existingClient.id);
                    
                    // --- Cargar el Chat ID ---
                    const { data: chat, error: chatError } = await supabase
                        .from('chats')
                        .select('id')
                        .eq('barber_id', this.barberData.id)
                        .eq('client_id', this.clientProfile.id)
                        .single();
                    
                    if (chatError || !chat) {
                        console.warn("No se encontró chat para cliente existente, se creará uno nuevo al chatear.");
                    } else {
                        this.chatId = chat.id;
                        this.subscribeToNotifications();
                    }
                    
                    this.addBotMessage(`<div class="bot-card"><p>¡Te encontré! Bienvenido de nuevo, <strong>${this.clientProfile.first_name}</strong>.</p></div>`);
                    this.showClientMainMenu();
                    return;
                }

                // --- Cliente No Encontrado: Crear uno nuevo ---
                const { data: newClient, error } = await supabase
                    .from('clients')
                    .insert({ 
                        phone_number: phone, 
                        first_name: 'Cliente', // Nombre temporal
                        last_name: phone.slice(-4) // Apellido temporal
                    })
                    .select()
                    .single();
                
                this.hideTyping();

                if (error || !newClient) { // Comprobación más robusta
                    this.addBotMessage(`<div class="bot-card"><p>❌ Error al crear tu perfil: ${error ? error.message : 'Respuesta inesperada.'}. Asegúrate de que el teléfono sea válido.</p></div>`);
                    this.currentFlow = 'awaiting_phone'; // Volver a pedir el teléfono
                    return; // ¡¡AÑADIDO!!
                }

                this.clientProfile = newClient;
                localStorage.setItem('clientId', newClient.id);
                
                // --- INICIO DE LA SOLUCIÓN ---
                // Crear el chat inmediatamente para este nuevo cliente
                // para que this.chatId esté disponible.
                this.showTyping();
                const { data: newChat, error: newChatError } = await supabase
                    .from('chats')
                    .insert({
                        barber_id: this.barberData.id,
                        client_id: this.clientProfile.id
                    })
                    .select('id')
                    .single();
                this.hideTyping();

                if (newChatError) {
                    // Error al crear el chat (muy poco probable si el cliente se creó bien)
                    this.addBotMessage(`<div class="bot-card"><p>❌ Error al iniciar tu chat. Por favor, recarga la página.</p></div>`);
                    console.error("Error creating chat for new user:", newChatError);
                    return; // Detener si no se puede crear el chat
                }
                
                this.chatId = newChat.id; // <-- ¡Establecer el ID del chat!
                // --- FIN DE LA SOLUCIÓN ---

                this.addBotMessage('<div class="bot-card"><p>¡Bienvenido! Hemos creado un perfil básico para ti.</p></div>');
                this.showClientMainMenu();
            }

            async handleCodeEntry(code) {
                this.showTyping();
                await this.loadBarberData(code.toUpperCase());
                
                const clientId = localStorage.getItem('clientId');
                
                if (clientId) {
                    await this.loadClientProfile(clientId);
                } else {
                    this.hideTyping();
                    this.addBotMessage(`<div class="bot-card"><p>¡Conectado con <strong>${this.barberData.barber_shop_name}</strong>! 💈</p><p>Para continuar, necesito tu número de teléfono (solo números, ej: 04121234567).</p></div>`);
                    this.currentFlow = 'awaiting_phone';
                }
            }


            showClientMainMenu() {
                const menuHTML = `
                <div class="bot-card">
                    <h3>Menú Principal</h3>
                    <p>¿Qué te gustaría hacer hoy?</p>
                    <div class="command-buttons-container">
                        <button class="command-button" data-command="/reservar">📅 Reservar una Cita</button>
                        <button class="command-button" data-command="/hablar">💬 Hablar con el Barbero</button>
                        <button class="command-button" data-command="/miperfil">👤 Mi Perfil</button>
                        <button class="command-button" data-command="/pagar_qr">💸 Registrar un Pago (QR)</button>
                        <button class="command-button" data-command="/servicios">💈 Ver Servicios</button>
                        <button class="command-button" data-command="/horario">⏰ Ver Horarios</button>
                        <button class="command-button" data-command="/suscribirse_notificaciones">🔔 Activar Notificaciones</button>
                    </div>
                </div>`;
                this.addBotMessage(menuHTML);
                this.currentFlow = 'main_menu';
            }
            
            async showServices() {
                // Refrescar datos
                await this.loadBarberData(this.barberData.public_code, false); 
                const servicesData = this.barberData.services || {};
                
                let contentHTML = '';
                
                if (Object.keys(servicesData).length === 0) {
                     contentHTML = '<p>Este barbero aún no ha definido sus servicios.</p>';
                } else {
                    for (const barberName in servicesData) {
                        const services = servicesData[barberName];
                        if (services.length > 0) {
                            contentHTML += `<h4>Servicios de ${barberName}</h4><ul>`;
                            contentHTML += services.map(s => `<li><span class="item-name">${s.name}</span><span class="item-detail">${s.price} Bs.</span></li>`).join('');
                            contentHTML += `</ul>`;
                        }
                    }
                    if (contentHTML === '') {
                         contentHTML = '<p>No hay servicios definidos por el momento.</p>';
                    }
                }
                
                this.addBotMessage(`<div class="bot-card"><h3>💈 Nuestros Servicios</h3>${contentHTML}${this.mainMenuButton}</div>`);
            }
            
            async showAvailability() {
                // Refrescar datos
                await this.loadBarberData(this.barberData.public_code, false); 
                const availabilityData = this.barberData.availability || {};
                const days = { mon: 'Lunes', tue: 'Martes', wed: 'Miércoles', thu: 'Jueves', fri: 'Viernes', sat: 'Sábado', sun: 'Domingo' };
                
                let contentHTML = '';
                
                if (Object.keys(availabilityData).length === 0) {
                     contentHTML = '<p>Este barbero aún no ha definido sus horarios.</p>';
                } else {
                    for (const barberName in availabilityData) {
                         const schedule = availabilityData[barberName];
                         contentHTML += `<h4>Horario de ${barberName}</h4><ul>`;
                         contentHTML += Object.keys(days).map(dayKey => {
                            const hours = schedule[dayKey] || [];
                            let timeRange = 'Cerrado';
                            if (hours.length > 0) {
                                const start = String(Math.min(...hours)).padStart(2, '0');
                                const end = String(Math.max(...hours) + 1).padStart(2, '0'); // +1 para que sea "hasta"
                                timeRange = `${start}:00 - ${end}:00`;
                            }
                            return `<li><span class="item-name">${days[dayKey]}</span><span class="item-detail">${timeRange}</span></li>`;
                         }).join('');
                         contentHTML += `</ul>`;
                    }
                }
                
                this.addBotMessage(`<div class="bot-card"><h3>⏰ Nuestros Horarios</h3>${contentHTML}${this.mainMenuButton}</div>`);
            }
            
            async enterLiveChatMode() {
                this.currentFlow = 'live_chat';
                this.messagesContainer.innerHTML = ''; // Limpiar mensajes del bot
                this.menuButton.classList.add('visible'); // Mostrar botón de menú
                this.resetUnreadCount(); // Marcar como leído
                
                if (this.notificationSubscription) {
                    this.notificationSubscription.unsubscribe();
                    this.notificationSubscription = null;
                }
                
                if (!this.clientProfile || !this.barberData) {
                    this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;"><p>❌ Error al cargar el chat: Faltan datos del cliente o del barbero.</p></div>`);
                    console.error("Cannot get/create chat without client or barber data.");
                    return;
                }

                // --- Asegurar que this.chatId exista ---
                if (!this.chatId) {
                    this.showTyping();
                    // Intentar encontrarlo primero
                    let { data: chat, error: findError } = await supabase
                        .from('chats')
                        .select('id')
                        .eq('barber_id', this.barberData.id)
                        .eq('client_id', this.clientProfile.id)
                        .single();
                        
                    if (findError && findError.code !== 'PGRST116') { // PGRST116 = 0 filas
                         // Error real
                         this.hideTyping();
                         this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;"><p>❌ Error buscando tu sala de chat: ${findError.message}</p></div>`);
                         return;
                    }

                    if (!chat) {
                        // Si no existe, crearlo
                        const { data: newChat, error: createError } = await supabase
                            .from('chats')
                            .insert({ barber_id: this.barberData.id, client_id: this.clientProfile.id })
                            .select('id')
                            .single();
                        
                        if (createError) {
                            this.hideTyping();
                            this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;"><p>❌ Error al crear tu sala de chat: ${createError.message}</p></div>`);
                            return;
                        }
                        this.chatId = newChat.id;
                    } else {
                        this.chatId = chat.id;
                    }
                    this.hideTyping();
                }

                // --- Cargar historial de mensajes ---
                this.showTyping();
                const { data: messages, error } = await supabase
                    .from('messages')
                    .select('*')
                    .eq('chat_id', this.chatId)
                    .order('created_at', { ascending: true });
                
                this.hideTyping();

                if (error) {
                    this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;"><p>❌ Error al cargar el historial.</p></div>`);
                    console.error("Error fetching chat history:", error);
                } else {
                    this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #FFB300;"><p>Estás en el chat directo. Escribe tu mensaje.</p><p class="helper-text">Usa el botón ☰ para volver al menú.</p></div>`);
                    messages.forEach(msg => this.renderMessage(msg, false));
                }

                // Suscribirse a nuevos mensajes
                this.subscribeToLiveChat();
            }
            
            renderMessage(message, isNew = true) {
                const messageDiv = document.createElement('div');
                const senderClass = (message.sender_type === 'client') ? 'user' : 'bot';
                messageDiv.className = `message ${senderClass}`;
                
                const time = new Date(message.created_at || Date.now()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                messageDiv.innerHTML = `
                    <div class="message-content">${message.content}</div>
                    <div class="message-time">${time}</div>
                `;
                
                // --- MODIFICACIÓN INDICADOR DE ESCRITURA ---
                // Insertar el nuevo mensaje ANTES del indicador de escritura del barbero
                const typingIndicator = document.getElementById('barber-typing-indicator');
                this.messagesContainer.insertBefore(messageDiv, typingIndicator);
                
                if (isNew) {
                    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
                }
            }


            subscribeToLiveChat() {
                if (this.chatSubscription || !this.chatId) return;

                const typingIndicator = document.getElementById('barber-typing-indicator');

                this.chatSubscription = supabase.channel(`live_chat_${this.chatId}`)
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'messages',
                        filter: `chat_id=eq.${this.chatId}`
                    }, (payload) => {
                        // Ocultar indicador de escritura si el nuevo mensaje es del barbero
                        if (payload.new.sender_type === 'barber') {
                            typingIndicator.style.display = 'none';
                        }
                        this.renderMessage(payload.new);
                    })
                    .on('broadcast', { event: 'typing' }, (payload) => {
                        // Mostrar indicador solo si es el barbero quien escribe
                        if (payload.sender === 'barber') {
                            typingIndicator.style.display = 'flex';
                            this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
                        }
                    })
                    .on('broadcast', { event: 'stopped-typing' }, (payload) => {
                         // Ocultar indicador si el barbero dejó de escribir
                        if (payload.sender === 'barber') {
                            typingIndicator.style.display = 'none';
                        }
                    })
                    .subscribe((status, err) => {
                        if (status === 'SUBSCRIBED') {
                            console.log('Conectado al chat en vivo.');
                        } else if (err) {
                            console.error('Error de conexión al chat en vivo:', err);
                            this.addBotMessage(`<div class="bot-card" style="border-left: 4px solid #F44336;"><p>❌ Error de conexión al chat en vivo.</p></div>`);
                        }
                    });
            }

            async sendRealtimeMessage(text) {
                if (!this.chatId) {
                    console.error("No chatId, cannot send message.");
                    return;
                }
                
                const messageData = {
                    chat_id: this.chatId,
                    content: text,
                    sender_type: 'client'
                };

                const { error } = await supabase.from('messages').insert(messageData);

                if (error) {
                    console.error("Error sending message:", error);
                    // Opcional: mostrar un error en la UI
                }
                // El mensaje se renderizará a través del realtime subscription
            }
            
            // --- Funciones de UI ---
            addMessage(text, sender, isNew = true) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}`;
                
                const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                messageDiv.innerHTML = `
                    <div class="message-content">${text}</div>
                    <div class="message-time">${time}</div>
                `;
                
                // Insertar el nuevo mensaje ANTES del indicador de escritura
                const typingIndicator = document.getElementById('barber-typing-indicator');
                this.messagesContainer.insertBefore(messageDiv, typingIndicator);
                
                if (isNew) {
                    this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
                }
            }

            addUserMessage(text) {
                this.addMessage(text, 'user');
            }

            addBotMessage(htmlContent) {
                this.addMessage(htmlContent, 'bot');
            }
            
            showTyping() {
                if (this.isTyping) return;
                this.isTyping = true;
                const typingDiv = document.createElement('div');
                typingDiv.className = 'message bot';
                typingDiv.id = 'typing-indicator';
                typingDiv.innerHTML = `
                    <div class="typing">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                `;
                // Insertar el indicador de "escribiendo" del BOT al final
                const typingIndicator = document.getElementById('barber-typing-indicator');

                this.messagesContainer.insertBefore(typingDiv, typingIndicator);
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }

            hideTyping() {
                this.isTyping = false;
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }
        }

        // Iniciar la app
        const app = new ClientChatApp();
        
        // Registrar el Service Worker para PWA y Notificaciones
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw-cliente.js')
                    .then(registration => {
                        console.log('Cliente Service Worker registrado con éxito:', registration);
                    })
                    .catch(error => {
                        console.error('Error al registrar el Cliente Service Worker:', error);
                    });
            });
        }
        
        // Para que el botón de confirmación de pago QR funcione
        window.app = app;

    </script>
</body>
</html>
